#include <asm/io.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <asm/ioctl.h>
#include <linux/uaccess.h>
#include <asm/cacheflush.h>
#include <asm/barrier.h>


#define CACHE_LINE_SIZE 1024
#define ALIGN_CACHE __attribute__ ((aligned (CACHE_LINE_SIZE)))

struct DataArray {
    size_t ALIGN_CACHE size;
    uint8_t ALIGN_CACHE __user *data;
};

struct bound_check_bypass_request {
    struct DataArray __user *data;
    uint8_t __user *cache_probe;
    uint8_t mask;
    size_t index;
};

struct function_array_request {
    size_t function_index;
    uint8_t arg1;
    void __user *arg2;
    void __user *arg3;
};


static long func0(uint8_t arg1, void __user *arg2, void __user *arg3) {
    printk(KERN_INFO "Called function array 0, args=[%d, %p, %p]\n", arg1, arg2, arg3);
    return arg1;
}
static long func1(uint8_t arg1, void __user *arg2, void __user *arg3) {
    printk(KERN_INFO "Called function array 1, args=[%d, %p, %p]\n", arg1, arg2, arg3);
    return arg1;
}
static long func2(uint8_t arg1, void __user *arg2, void __user *arg3) {
    printk(KERN_INFO "Called function array 2, args=[%d, %p, %p]\n", arg1, arg2, arg3);
    return arg1;
}
static long func3(uint8_t arg1, void __user *arg2, void __user *arg3) {
    printk(KERN_INFO "Called function array 3, args=[%d, %p, %p]\n", arg1, arg2, arg3);
    return arg1;
}
static long func4(uint8_t arg1, void __user *arg2, void __user *arg3) {
    printk(KERN_INFO "Called function array 4, args=[%d, %p, %p]\n", arg1, arg2, arg3);
    return arg1;
}

typedef long (*function_ptr_t)(uint8_t arg1, void __user *arg2, void __user *arg3);

function_ptr_t function_array[] = {func0, func1, func2, func3, func4};
size_t function_array_size = ARRAY_SIZE(function_array);

#define IOCTL_BOUND_CHECK_BYPASS _IOWR('S', 'b', struct bound_check_bypass_request *)
#define IOCTL_FUNCTION_ARRAY     _IOWR('S', 'f', struct function_array_request *)

static long ioctl_function_array(struct function_array_request __user* arg) {
    struct function_array_request request;
    size_t function_index;
    uint8_t arg1;
    void __user* arg2;
    void __user* arg3;

    if (copy_from_user(&request, arg, sizeof(request)))
        return -EFAULT;

    function_index = request.function_index;
    arg1 = request.arg1;
    arg2 = request.arg2;
    arg3 = request.arg3;

    //Force Cache miss on function_array_size
//     clflush_cache_range(&function_array_size, sizeof(function_array_size));
//     mb();

    if (function_index < function_array_size) {
        return function_array[function_index](arg1, arg2, arg3);
    } else {
        printk(KERN_INFO "Invalid index %zd points to 0x%p\n", function_index, &function_array[function_index]);
        return -EFAULT;
    }
}

static long ioctl_bound_check_bypass(struct bound_check_bypass_request __user* arg) {
    struct bound_check_bypass_request request;
    size_t data_size;
    uint8_t* data_ptr;
    uint8_t* cache_probe_ptr;
    uint8_t data;
    uint8_t mask;
    size_t index;
    volatile uint8_t cache_probe;

    if (copy_from_user(&request, arg, sizeof(request)))
        return -EFAULT;

    if (get_user(data_ptr, &request.data->data))
        return -EFAULT;

    if (get_user(data_size, &request.data->size))
        return -EFAULT;

    index = request.index;
    mask = request.mask;
    cache_probe_ptr = request.cache_probe;

    if (index < data_size) {
        if (get_user(data, data_ptr + index))
            return -EFAULT;

        if (get_user(cache_probe, cache_probe_ptr + (data & mask) * CACHE_LINE_SIZE))
            return -EFAULT;

        return data;
    } else {
        return -EINVAL;
    }
}

static long foobar_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
//     printk(KERN_INFO "foobar_ioctl: %d %p\n", cmd, (void*)arg);
    switch (cmd) {
        case IOCTL_FUNCTION_ARRAY:
            return ioctl_function_array((struct function_array_request __user*)arg);
        case IOCTL_BOUND_CHECK_BYPASS:
            return ioctl_bound_check_bypass((struct bound_check_bypass_request __user*)arg);
        default:
            return -EINVAL;
    };
}
static int show_foobar(struct seq_file *m, void *v) {
    seq_printf(m, "function_array=0x%zx\n", (size_t)&function_array);
    seq_printf(m, "function_array_size=%ld\n", (size_t)function_array_size);
    seq_printf(m, "function_array_size_ptr=0x%zx\n", (size_t)&function_array_size);
    seq_printf(m, "phys_to_virt=0x%zx\n", (size_t)phys_to_virt(0));
    return 0;
}
static int foobar_open(struct inode *inode, struct file *file) {
  return single_open(file, show_foobar, NULL);
}
static struct file_operations foobar_fops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = foobar_ioctl,
    .open = foobar_open,
    .release = single_release,
    .read = seq_read,
    .llseek = seq_lseek,
};



static int __init kaslr_init(void) {
  struct proc_dir_entry *entry;
  printk(KERN_INFO "Module start: %lu\n", IOCTL_BOUND_CHECK_BYPASS);
  entry = proc_create("foobar", 0777, NULL, &foobar_fops);
  if (!entry) {
    return -1;
  } else {
    printk(KERN_INFO "Create proc file was successful\n");
  }
  return 0;
}

static void __exit kaslr_exit(void) {
  remove_proc_entry("foobar", NULL);
  printk(KERN_INFO "Module end\n");
}

module_init(kaslr_init);
module_exit(kaslr_exit);
MODULE_LICENSE("GPL");
